//! TypeScript Client Generator
//!
//! Generates TypeScript/JavaScript client code for interacting with the Anchor program.

use crate::ir::*;
use crate::CodegenError;

/// TypeScript client generator
pub struct TypeScriptGenerator {
    program_name: String,
}

impl Default for TypeScriptGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl TypeScriptGenerator {
    pub fn new() -> Self {
        Self {
            program_name: String::new(),
        }
    }

    /// Generate the TypeScript client file
    pub fn generate(&mut self, ir: &SolanaProgram) -> Result<String, CodegenError> {
        self.program_name = to_camel_case(&ir.name);

        let mut output = String::new();

        // Header and imports
        output.push_str(&self.generate_header());
        output.push('\n');

        // Types for state accounts
        output.push_str(&self.generate_state_types(ir)?);
        output.push('\n');

        // Types for events
        output.push_str(&self.generate_event_types(ir)?);
        output.push('\n');

        // Types for errors
        output.push_str(&self.generate_error_types(ir)?);
        output.push('\n');

        // Main client class
        output.push_str(&self.generate_client_class(ir)?);

        Ok(output)
    }

    fn generate_header(&self) -> String {
        format!(
            r#"/**
 * Generated by SolScript compiler
 * TypeScript client for {} program
 */

import {{
  Connection,
  PublicKey,
  Keypair,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  SYSVAR_RENT_PUBKEY,
}} from '@solana/web3.js';
import * as anchor from '@coral-xyz/anchor';
import {{ Program, AnchorProvider, BN }} from '@coral-xyz/anchor';

// Program ID - replace with your deployed program ID
export const PROGRAM_ID = new PublicKey('11111111111111111111111111111111');
"#,
            self.program_name
        )
    }

    fn generate_state_types(&self, ir: &SolanaProgram) -> Result<String, CodegenError> {
        let mut output = String::new();
        output.push_str("// State account types\n");

        // Main state account
        output.push_str(&format!("export interface {}State {{\n", self.program_name));
        for field in &ir.state.fields {
            let ts_type = self.solana_type_to_ts(&field.ty);
            output.push_str(&format!(
                "  {}: {};\n",
                to_camel_case_lower(&field.name),
                ts_type
            ));
        }
        output.push_str("}\n\n");

        // Mapping entry types
        for mapping in &ir.mappings {
            output.push_str(&format!(
                "export interface {}Entry {{\n",
                to_camel_case(&mapping.name)
            ));
            output.push_str(&format!(
                "  value: {};\n",
                self.solana_type_to_ts(&mapping.value_ty)
            ));
            output.push_str("}\n\n");
        }

        Ok(output)
    }

    fn generate_event_types(&self, ir: &SolanaProgram) -> Result<String, CodegenError> {
        let mut output = String::new();
        output.push_str("// Event types\n");

        for event in &ir.events {
            output.push_str(&format!(
                "export interface {}Event {{\n",
                to_camel_case(&event.name)
            ));
            for field in &event.fields {
                let ts_type = self.solana_type_to_ts(&field.ty);
                output.push_str(&format!(
                    "  {}: {};\n",
                    to_camel_case_lower(&field.name),
                    ts_type
                ));
            }
            output.push_str("}\n\n");
        }

        Ok(output)
    }

    fn generate_error_types(&self, ir: &SolanaProgram) -> Result<String, CodegenError> {
        let mut output = String::new();
        output.push_str("// Custom errors\n");
        output.push_str("export enum CustomError {\n");
        output.push_str("  RequireFailed = 'RequireFailed',\n");

        for error in &ir.errors {
            output.push_str(&format!(
                "  {} = '{}',\n",
                to_camel_case(&error.name),
                error.name
            ));
        }

        output.push_str("}\n\n");
        Ok(output)
    }

    fn generate_client_class(&self, ir: &SolanaProgram) -> Result<String, CodegenError> {
        let mut output = String::new();
        let class_name = format!("{}Client", self.program_name);

        output.push_str(&format!(
            r#"/**
 * Client for interacting with the {} program
 */
export class {} {{
  private provider: AnchorProvider;

  constructor(provider: AnchorProvider) {{
    this.provider = provider;
  }}

  /**
   * Get the state account PDA
   */
  getStatePDA(): [PublicKey, number] {{
    return PublicKey.findProgramAddressSync(
      [Buffer.from('state')],
      PROGRAM_ID
    );
  }}

"#,
            self.program_name, class_name
        ));

        // Generate mapping PDA helpers
        for mapping in &ir.mappings {
            output.push_str(&format!(
                r#"  /**
   * Get PDA for {} mapping entry
   */
  get{}PDA(key: PublicKey): [PublicKey, number] {{
    return PublicKey.findProgramAddressSync(
      [Buffer.from('{}'), key.toBuffer()],
      PROGRAM_ID
    );
  }}

"#,
                mapping.name,
                to_camel_case(&mapping.name),
                to_snake_case(&mapping.name)
            ));
        }

        // Generate instruction methods
        for instruction in &ir.instructions {
            output.push_str(&self.generate_instruction_method(instruction)?);
        }

        output.push_str("}\n");
        Ok(output)
    }

    fn generate_instruction_method(
        &self,
        instruction: &Instruction,
    ) -> Result<String, CodegenError> {
        let method_name = to_camel_case_lower(&instruction.name);

        // Build parameter list
        let mut params: Vec<String> = Vec::new();

        // Add accounts parameter
        params.push("accounts: { state: PublicKey; signer: Keypair }".to_string());

        // Add instruction parameters
        for param in &instruction.params {
            let ts_type = self.solana_type_to_ts(&param.ty);
            params.push(format!("{}: {}", to_camel_case_lower(&param.name), ts_type));
        }

        let params_str = params.join(", ");

        // Determine return type (for documentation purposes)
        let _return_type = if let Some(ref ret) = instruction.returns {
            self.solana_type_to_ts(ret)
        } else {
            "void".to_string()
        };

        let mut output = String::new();
        output.push_str(&format!(
            r#"  /**
   * Call the {} instruction
   */
  async {}({}): Promise<string> {{
    // Build and send transaction
    // This is a placeholder - actual implementation depends on IDL
    const tx = new Transaction();

    // Add instruction to transaction
    // tx.add(await this.program.methods.{}(...).accounts({{...}}).instruction());

    const signature = await this.provider.sendAndConfirm(tx, [accounts.signer]);
    return signature;
  }}

"#,
            instruction.name, method_name, params_str, method_name
        ));

        Ok(output)
    }

    fn solana_type_to_ts(&self, ty: &SolanaType) -> String {
        match ty {
            SolanaType::U8 | SolanaType::U16 | SolanaType::U32 => "number".to_string(),
            SolanaType::U64 | SolanaType::U128 => "BN".to_string(),
            SolanaType::I8 | SolanaType::I16 | SolanaType::I32 => "number".to_string(),
            SolanaType::I64 | SolanaType::I128 => "BN".to_string(),
            SolanaType::Bool => "boolean".to_string(),
            SolanaType::String => "string".to_string(),
            SolanaType::Pubkey => "PublicKey".to_string(),
            SolanaType::Signer => "PublicKey".to_string(),
            SolanaType::Bytes => "Buffer".to_string(),
            SolanaType::FixedBytes(_) => "Uint8Array".to_string(),
            SolanaType::Array(inner, _size) => format!("{}[]", self.solana_type_to_ts(inner)),
            SolanaType::Vec(inner) => format!("{}[]", self.solana_type_to_ts(inner)),
            SolanaType::Option(inner) => format!("{} | null", self.solana_type_to_ts(inner)),
            SolanaType::Mapping(key, value) => {
                format!(
                    "Map<{}, {}>",
                    self.solana_type_to_ts(key),
                    self.solana_type_to_ts(value)
                )
            }
            SolanaType::Custom(name) => name.clone(),
        }
    }
}

// Helper functions for case conversion
fn to_camel_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' || c == '-' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

fn to_camel_case_lower(s: &str) -> String {
    let camel = to_camel_case(s);
    let mut chars = camel.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_ascii_lowercase().to_string() + chars.as_str(),
    }
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() && i > 0 {
            result.push('_');
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c.to_ascii_lowercase());
        }
    }
    result
}
